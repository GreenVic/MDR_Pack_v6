# Пример сохранения данных в EEPROM

Для запуска, необходимо выбрать проект под свой микроконтроллер, скомпилировать и загрузить.

Использованы следующие кнопки:
UP - Выбор размера и места хранения данных
  Main - Страница в основную память
  Info - Страница в информационной памяти
  MainBf - Буфер, превышающий страницу, в основную память
  InfoBf - Буфер, превышающий страницу, в информационную память

RIGHT - Запись данных.
  Данные зависят от адреса данных и определения USE_PSEUDO_RAND_VALUES
  USE_PSEUDO_RAND_VALUES = 0,  Записываются просто индексы + RunIndex
  USE_PSEUDO_RAND_VALUES = 1,  Записываются псевдо-случайные значения + RunIndex
  
  RunIndex - значение, миняющееся на +1 при каждой операции записи (нажатии RIGHT). RunIndex - свой для основной и информационной памяти. Это гарантирует, что записываемые данные всегда новые.

  RunIndex сохраняется в регистрах блока BKP, чтобы данные можно было сравнить и после Reset микроконтроллера.

DOWN - Сравнение данных.
  Считываются данные и сравниваются с заново рассчитанными. Поскольку исходные данные для рассчета не менялись (индекс RunIndex хранился в памяти и более не менялся), то данные должны совпадать.

Статус сравнения выводится на LCD.

## Пример теста, нажимаем:

UP - выбираем Main
RIGHT - записываем данные
DOWN - считываем данные, смотрим результат на LCD. Должны совпасть.
Reset - сброс МК
DOWN - считываем данные, смотрим результат на LCD. Должны совпасть.
и т.п.

После сброса по питанию данные совпадать не будут, поскольку значение RunIndex в BKP будет утеряно, если не установлена батарейка.

Тоже самое можно сделать для памяти Info.

Можно комбинировать тесты в ту или иную память, но важно, чтобы не пересекались тесты Main-MainBf, а так же Info-InfoBf. Поскольку значение RunIndex хранится по одному на банк памяти и соответствует последней операции записи, а это может быть либо Main, либо MainBf. Иначе потребуется модификация алгоритма теста.

(Изначально тест был написан для режимов Main и Info, затем были дописаны модификациями с записью буферов в несколько страниц.)

## Запись буфера.
Функции запись буфера более применимы, поскольку требуется только указать, сколько памяти необходимо для хранения. Функции очистят необходимые страницы и произведут запись в них.

uint32_t MDR_EEPROM_EraseForBuff(uint32_t pageStartAddr, uint32_t count, MDR_EEPROM_MEM memBank);
Принимает на вход начальный адрес страницы, с которой будет очищено место под массив данных.
Возвращает количество стертых слов, всегда кратно размеру страницы - т.к. стирание возможно только по страниам.

void MDR_EEPROM_WriteBuff(uint32_t addr, uint32_t count, uint32_t * data, MDR_EEPROM_MEM memBank);
Запишет массив данных начиная с указанного адреса. Адрес должен лежать в стертой области и не обязан совпадать с размером страницы. Данные не должны выходить за диапазон стертых вдресов.

void MDR_EEPROM_ReadBuff (uint32_t addr, uint32_t count, uint32_t * data, MDR_EEPROM_MEM memBank);
Считывает данные начиная с указанного адреса.


## Подключение Jtag (с которым проверялся пример)
1986VE91: JtagB
1986VE92: JtagB
1986VE93:   JtagA!
1986VC1 : JtagB