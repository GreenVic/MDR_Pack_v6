# Сравнение вариантов реализации функции задержки Delay

При написании функции задержки на языке Си, возникает зависимость от компилятора и его текущих опций оптимизации. Чтобы исключить данную зависимость реализована функция на ассемблере. Предполагается что в данном случае при любом уровне оптимизации конечный ассемблерный код будет вставлен как есть и займет заранее известное число тактов, что в свою очередь даст необходимую задержку.

В проекте на пин светодиода выводятся импульсы длительностью по 3мс, задержка между фронтами реализована различными реализациями функции Delay. Импульсы необходимо смотреть осциллографом.

  * Вариант на ассемблере, исполняется из EEPROM.
  * Вариант на ассемблере, исполняется из ОЗУ.
  * Вариант на Си, исполняется из EEPROM. Используется для сравнения с ассемблерными вариантами.
  * Вариант через блок отладки DWT, есть только в Cortex-M3 и Cortex-M4.

Проект собрался и запускался в 4-х вариантах, все под компилятором ARM Compiler V5:
  * Тактирование от HSI, оптимизация -О0 
  * Тактирование от HSI, оптимизация -О2
  * Тактирование на максимальной частоте от HSE через PLL, оптимизация -О2  
  * Тактирование на максимальной частоте от HSE через PLL, оптимизация -О0

Значения LOOP_CYCLES_х определяют сколько тактов исполняется один цикл внутри функции задержки, т.е. соответственно это LOOP_CYCLES_ASM, LOOP_CYCLES_ASM_RAM, LOOP_CYCLES_C, LOOP_CYCLES_DWT. Данные значения подбирались для варианта тактирования от "HSI оптимизация -О0" так, чтобы импульсы на осциллографе составляли заданные 3мс. Оставшиеся три варианта сборки (с другой частотой и оптимизацией) показывали как меняется импульс на осциллографе относительно начальных 3мс.

Результаты отражены коментариями в файле main.c. 
Итоги: 
  * В 1986ВЕ9х и 1986ВЕ8Т лучше использовать задержку на основе блока DWT, она самая точная и не зависит от кода впринципе.
  * В 1986ВЕ1Т и 1986ВЕ9х цикл исполняется быстрее из EEPROM чем из ОЗУ. Это означает, что отрабатывает флэш-ускоритель. Т.е. весь код цикла влез в буфер и ядро не образается за командами в EEPROM, исполнение занимает 3-4 цикла. В ОЗУ ускорителя нет, поэтому выборка команд цикла и исполнение занимает 8 тактов. (Важно что ассемблерный код работает только с регистрами и не обращается к памяти за данными, иначе код вероятно отрабатывал бы еще медленнее. Поскольку кроме шины инструкций, отрабатывала бы еще и шина данных.)
  * В 1986ВЕ4У ускорителя флеш нет, цикл исполняется за 8 тактов. При доступе к ОЗУ исполнение занимает 4 такта. Видимо доступ к ОЗУ происходит быстрее чем к EEPROM.
  * В 1986ВЕ8 проверен доступ только из ОЗУ, прошивать ради подобного теста дорогостоящую ОТР не представляется разумным.

  